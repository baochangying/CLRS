# 2.1-1
> 以图2-2为模型，说明INSERTION-SORT在数组A=<31,41,59,26,41,58>上的运行过程。

#### **初始数组**：

A=<31,41,59,26,41,58>

#### **第1次循环**：

j=2,A[j]也就是A[2]的值赋值给key,然后比较A[1]与A[2]，发现A[1] < A[2]

原数组不变

#### **第2次循环**：

j=3,A[3]的值赋值给key,比较A[2]与A[3]，A[2] < A[3]
原数组不变

#### **第3次循环**：

j=4,A[4]的值赋值给key,比较A[3]与A[4]，A[3] > A[4] 将A[3]的值赋给A[4], A[2] > A[4] 将A[2]的值赋给A[3], A[1] > A[4] 将A[1]的值赋给A[2],将key的值赋给A[1]
A=<26,31,41,59,41,58>

#### **第4次循环**：

j=5,A[5]的值赋值给key,比较A[4]与A[5]，A[4] > A[5] 将A[4]的值赋给A[5],将key的值赋给A[4]
A=<26,31,41,41,59,58>

#### **第5次循环**：

j=6,A[6]的值赋值给key,比较A[5]与A[6]，A[5] > A[6] 将A[5]的值赋给A[6],将key的值赋给A[5]
A=<26,31,41,41,58,59>·

# 2.1-2

> 重写过程 INSERTION-SORT,使之按非升序排序。

```
for i = 2 to A.length
    key = A[i]
    j = i - 1
    while j >= 1 and A[j]  < key
        A[j+1] = A[j]
        j = j - 1
    A[j+1] = key
```

# 2.1-3

> 考虑以下查找问题：
输入：n个数字的序列A=⟨A 1，A 2，…，A n⟩和一个值v。 
输出：一个索引i，使得v=A[i]，或者如果v不出现在A中，则为特殊值NIL。 
编写线性搜索的伪代码，该代码扫描序列，寻找v。使用循环不变量，证明你的算法是正确的。确保你的循环不变量满足三个必要的属性。

```
LINEAR_SEARCH(A,v)
for i = 1 to A.length
    if A[i] == v
        return i
    return -1
```

# 2.1-4

> 考虑将存储在两个n元素数组A和B中的两个n位二进制整数相加的问题。这两个整数的和应该以二进制形式存储在（n+1）元素数组C中。正式陈述问题，并编写用于将两个整数相加的伪代码。

```
ADD_BINARY_INTEGERS(A,B)
    carry = 0                  // 初始化进位为 0
    for i = 1 to A.length      // 从最低位开始遍历
        sum = A[i] + B[i] + carry  // 计算当前位的和
        C[i] = sum % 2         // 当前位的结果是 sum 对 2 取余
        carry = sum / 2        // 计算进位
    C[A.length + 1] = carry    // 将最高位的进位存储到 C 的最后一位
    return C                   // 返回结果数组 C
```